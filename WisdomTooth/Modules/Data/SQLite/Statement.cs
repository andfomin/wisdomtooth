using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;

namespace MediaCurator.Data.SQLite
{
    internal class Statement : IDisposable
    {
        private IntPtr handle;
        private Connection connection;
        public string Sql { get; private set; }

        public Statement(Connection connection, string sql)
        {
            Sql = sql;
            this.connection = connection;
            this.connection.AddStatement(this);

            var error = SQLite.sqlite3_prepare16_v2(connection, sql, -1, out this.handle, IntPtr.Zero);

            var attempt = 0;
            while ((error == SQLite.SQLITE_BUSY) && (attempt < 200))
            {
                Thread.Sleep(5);
                attempt++;
                error = SQLite.sqlite3_prepare16_v2(connection, sql, -1, out this.handle, IntPtr.Zero);
            }

            this.connection.NoError(error, "51632922 " + sql, true);
        }

        public void Dispose()
        {
            if (this.handle != IntPtr.Zero)
            {
                /* Any error that is returned was generated by the last call to sqlite3_step(). */
                SQLite.sqlite3_finalize(this);
                this.handle = IntPtr.Zero;

                this.connection.RemoveStatement(this);
            }
        }

        /// <summary>
        /// Provide implicit conversion of an Statement object to a IntPtr handle. 
        /// This is done so that an Statement can be used anywhere a statement handle is required.
        /// </summary>
        /// <param name="esentTable">The Statement to convert.</param>
        /// <returns>The IntPtr wrapped by the Statement.</returns>
        public static implicit operator IntPtr(Statement statement)
        {
            return statement.handle;
        }

        public int Step()
        {
            var error = SQLite.sqlite3_step(this);
            switch (error)
            {
                case SQLite.SQLITE_ROW:
                case SQLite.SQLITE_DONE:
                    break;
                default:
                    this.connection.NoError(error, "5153764", true);
                    break;
            }
            return error;
        }

        public bool TryStep()
        {
            var error = Step();
            return error == SQLite.SQLITE_ROW;
        }

        public void ExecuteConcurrently()
        {
            var error = SQLite.sqlite3_step(this);
            Reset();
            var attempt = 0;
            while ((error == SQLite.SQLITE_BUSY) && (attempt < 200))
            {
                Thread.Sleep(5);
                attempt++;
                error = SQLite.sqlite3_step(this);
                Reset();
            }
            this.connection.NoError(error, "5221009", true);
        }

        public void ResetAndClearBindings()
        {
            Reset();
            SQLite.sqlite3_clear_bindings(this); /* This function always returns SQLITE_OK. */
        }

        public void Reset()
        {
            SQLite.sqlite3_reset(this); /* Returns error depending on the previous sqlite3_step() */
        }

        public void BindInt(int parameterIndex, int value)
        {
            SQLite.sqlite3_bind_int(this, parameterIndex, value);
        }

        public void BindBytes(int parameterIndex, byte[] bytes)
        {
            unsafe
            {
                fixed (byte* pointer = bytes)
                {
                    BindBytes(parameterIndex, new IntPtr(pointer), bytes.Length, false);
                }
            }
        }

        /// <summary>
        /// Buffer is fixed in the memory
        /// </summary>
        /// <param name="parameterIndex"></param>
        /// <param name="pointer"></param>
        public void BindBytes(int parameterIndex, IntPtr data, int dataLength)
        {
            BindBytes(parameterIndex, data, dataLength, true);
        }

        private void BindBytes(int parameterIndex, IntPtr data, int dataLength, bool isFixed)
        {
            SQLite.sqlite3_bind_blob(
                this,
                parameterIndex,
                data,
                dataLength,
                new IntPtr(isFixed ? SQLite.SQLITE_STATIC : SQLite.SQLITE_TRANSIENT));
        }

        public byte[] ReadBytes(int columnIndex)
        {
            byte[] result = null;
            var length = SQLite.sqlite3_column_bytes(this, columnIndex);
            /* If SQLITE_NULL then size is 0 */
            if (length != 0)
            {
                result = new byte[length];
                IntPtr blob = SQLite.sqlite3_column_blob(this, columnIndex);
                Marshal.Copy(blob, result, 0, length);
            }
            return result;
        }

        public string ReadText(int columnIndex)
        {
            string result = null;            
            var length = SQLite.sqlite3_column_bytes16(this, columnIndex);
            /* If NULL then size is 0 */
            if (length != 0)
            {
                IntPtr utf16 = SQLite.sqlite3_column_text16(this, columnIndex);
                /* The value returned by sqlite3_column_bytes16() is the number of bytes in the string, not the number of characters. So, because utf-16 chars may theoretically be larger than 2 bytes, the simple calculation below is accurate only for the 64K chars in the Main Unicode Plane. */
                result = Marshal.PtrToStringUni(utf16, length / 2);
            }
            return result;
        }

        public int ReadInt(int columnIndex)
        {
            return SQLite.sqlite3_column_int(this, columnIndex);
        }

    }
}
